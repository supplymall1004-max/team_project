# Framer 웹사이트 디자인 기능 및 구현 가이드

## 목차
1. [개요](#개요)
2. [기술 스택](#기술-스택)
3. [모션 디자인 기능](#모션-디자인-기능)
4. [UI/UX 디자인 기능](#uiux-디자인-기능)
5. [구현 방법 상세 가이드](#구현-방법-상세-가이드)
6. [코드 예제](#코드-예제)
7. [최적화 및 성능](#최적화-및-성능)

---

## 개요

Framer는 React 기반의 노코드 웹사이트 빌더로, 디자이너들이 코드 없이 전문적이고 인터랙티브한 웹사이트를 만들 수 있도록 합니다. 특히 모션 디자인과 인터랙션에 강점을 가지고 있습니다.

### 주요 특징
- **노코드 빌더**: 코드 작성 없이 시각적 인터페이스로 웹사이트 제작
- **모션 디자인**: Framer Motion을 활용한 고급 애니메이션
- **반응형 디자인**: 자동 반응형 레이아웃 시스템
- **실시간 편집**: 온페이지 편집 기능
- **CMS 통합**: 내장 콘텐츠 관리 시스템

---

## 기술 스택

### 핵심 기술
- **React**: 사용자 인터페이스 구축을 위한 JavaScript 라이브러리
- **Framer Motion**: React 기반 애니메이션 라이브러리
- **TypeScript**: 타입 안정성을 위한 JavaScript 확장
- **Next.js**: React 프레임워크 (추정)

### 추가 기술
- **Google Tag Manager**: 분석 및 추적
- **Google One Tap**: 인증 시스템
- **Web Fonts**: 커스텀 폰트 (woff2)
- **CDN**: 이미지 및 에셋 최적화 (framerusercontent.com)

---

## 모션 디자인 기능

### 1. 스크롤 기반 변환 (Scroll Transforms)

**기능 설명:**
사용자의 스크롤 위치에 따라 요소가 이동, 페이드, 스케일 등의 효과를 받습니다.

**구현 방법:**

```typescript
import { motion, useScroll, useTransform } from 'framer-motion';

function ScrollTransformComponent() {
  const { scrollYProgress } = useScroll();
  
  // 스크롤 진행도에 따른 Y축 이동
  const y = useTransform(scrollYProgress, [0, 1], [0, -100]);
  
  // 스크롤 진행도에 따른 투명도 변화
  const opacity = useTransform(scrollYProgress, [0, 0.5, 1], [1, 0.5, 0]);
  
  // 스크롤 진행도에 따른 스케일 변화
  const scale = useTransform(scrollYProgress, [0, 0.5, 1], [1, 1.2, 0.8]);

  return (
    <motion.div
      style={{
        y,
        opacity,
        scale,
      }}
    >
      스크롤에 반응하는 콘텐츠
    </motion.div>
  );
}
```

**고급 활용:**
- 여러 요소를 다른 속도로 이동시켜 패럴랙스 효과 생성
- 스크롤 방향에 따라 다른 애니메이션 적용
- 스크롤 속도에 따른 애니메이션 강도 조절

### 2. 뷰포트 진입 효과 (Appear Effects)

**기능 설명:**
요소가 뷰포트에 진입할 때 자동으로 애니메이션이 실행됩니다.

**구현 방법:**

```typescript
import { motion, useInView } from 'framer-motion';
import { useRef } from 'react';

function AppearEffectComponent() {
  const ref = useRef(null);
  const isInView = useInView(ref, { once: true, amount: 0.3 });

  return (
    <motion.div
      ref={ref}
      initial={{ opacity: 0, y: 50 }}
      animate={isInView ? { opacity: 1, y: 0 } : { opacity: 0, y: 50 }}
      transition={{ duration: 0.6, ease: "easeOut" }}
    >
      뷰포트에 진입하면 나타나는 콘텐츠
    </motion.div>
  );
}
```

**다양한 진입 효과:**

```typescript
// 페이드 인
initial={{ opacity: 0 }}
animate={{ opacity: 1 }}

// 슬라이드 업
initial={{ opacity: 0, y: 50 }}
animate={{ opacity: 1, y: 0 }}

// 스케일 업
initial={{ opacity: 0, scale: 0.8 }}
animate={{ opacity: 1, scale: 1 }}

// 회전 효과
initial={{ opacity: 0, rotate: -10 }}
animate={{ opacity: 1, rotate: 0 }}

// 조합 효과
initial={{ opacity: 0, y: 50, scale: 0.9 }}
animate={{ opacity: 1, y: 0, scale: 1 }}
```

### 3. 컴포넌트 상태 관리 (Component States)

**기능 설명:**
호버, 클릭, 포커스 등의 상태에 따라 자동으로 전환 애니메이션이 적용됩니다.

**구현 방법:**

```typescript
import { motion } from 'framer-motion';

function InteractiveButton() {
  return (
    <motion.button
      whileHover={{ 
        scale: 1.05,
        boxShadow: "0 10px 20px rgba(0,0,0,0.2)"
      }}
      whileTap={{ 
        scale: 0.95 
      }}
      whileFocus={{
        outline: "2px solid #0066ff",
        outlineOffset: "4px"
      }}
      transition={{ 
        type: "spring", 
        stiffness: 400, 
        damping: 17 
      }}
    >
      인터랙티브 버튼
    </motion.button>
  );
}
```

**고급 상태 관리:**

```typescript
import { motion, AnimatePresence } from 'framer-motion';
import { useState } from 'react';

function StatefulComponent() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div>
      <motion.button
        onClick={() => setIsOpen(!isOpen)}
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
      >
        {isOpen ? '닫기' : '열기'}
      </motion.button>
      
      <AnimatePresence>
        {isOpen && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: "auto" }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.3 }}
          >
            콘텐츠가 나타나고 사라집니다
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
```

### 4. 레이아웃 애니메이션 (Layout Animations)

**기능 설명:**
요소의 위치나 크기가 변경될 때 자동으로 부드러운 전환 애니메이션이 적용됩니다.

**구현 방법:**

```typescript
import { motion } from 'framer-motion';
import { useState } from 'react';

function LayoutAnimationComponent() {
  const [items, setItems] = useState([1, 2, 3, 4, 5]);

  return (
    <div>
      {items.map((item) => (
        <motion.div
          key={item}
          layout
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.3 }}
        >
          아이템 {item}
        </motion.div>
      ))}
    </div>
  );
}
```

### 5. 경로 애니메이션 (Path Animations)

**기능 설명:**
SVG 경로를 따라 요소가 이동하거나 그려지는 애니메이션입니다.

**구현 방법:**

```typescript
import { motion } from 'framer-motion';

function PathAnimation() {
  const pathVariants = {
    hidden: { pathLength: 0, opacity: 0 },
    visible: {
      pathLength: 1,
      opacity: 1,
      transition: {
        pathLength: { duration: 2, ease: "easeInOut" },
        opacity: { duration: 0.5 }
      }
    }
  };

  return (
    <svg width="200" height="200">
      <motion.path
        d="M 10 100 Q 100 10 190 100"
        stroke="#0066ff"
        strokeWidth="3"
        fill="none"
        variants={pathVariants}
        initial="hidden"
        animate="visible"
      />
    </svg>
  );
}
```

---

## UI/UX 디자인 기능

### 1. 반응형 레이아웃 시스템

**기능 설명:**
자동으로 다양한 화면 크기에 맞춰 레이아웃이 조정됩니다.

**구현 방법:**

```typescript
import { motion, useMotionValue, useTransform } from 'framer-motion';
import { useWindowSize } from '@/hooks/use-window-size';

function ResponsiveLayout() {
  const { width } = useWindowSize();
  const isMobile = width < 768;
  const isTablet = width >= 768 && width < 1024;

  return (
    <motion.div
      style={{
        display: 'grid',
        gridTemplateColumns: isMobile 
          ? '1fr' 
          : isTablet 
          ? 'repeat(2, 1fr)' 
          : 'repeat(3, 1fr)',
        gap: isMobile ? '1rem' : '2rem',
      }}
      layout
    >
      {/* 콘텐츠 */}
    </motion.div>
  );
}
```

### 2. 온페이지 편집 (On-Page Editing)

**기능 설명:**
웹사이트를 직접 클릭하여 실시간으로 콘텐츠를 수정할 수 있습니다.

**구현 방법:**

```typescript
import { useState } from 'react';
import { motion } from 'framer-motion';

function EditableContent({ initialContent }: { initialContent: string }) {
  const [content, setContent] = useState(initialContent);
  const [isEditing, setIsEditing] = useState(false);

  return (
    <motion.div
      onClick={() => setIsEditing(true)}
      whileHover={{ backgroundColor: 'rgba(0,0,0,0.05)' }}
    >
      {isEditing ? (
        <input
          value={content}
          onChange={(e) => setContent(e.target.value)}
          onBlur={() => setIsEditing(false)}
          autoFocus
        />
      ) : (
        <span>{content}</span>
      )}
    </motion.div>
  );
}
```

### 3. 드래그 앤 드롭 인터페이스

**기능 설명:**
요소를 드래그하여 위치를 변경하거나 재배치할 수 있습니다.

**구현 방법:**

```typescript
import { motion, useMotionValue, useDragControls } from 'framer-motion';

function DraggableComponent() {
  const x = useMotionValue(0);
  const y = useMotionValue(0);
  const dragControls = useDragControls();

  return (
    <motion.div
      drag
      dragControls={dragControls}
      dragConstraints={{ left: 0, right: 0, top: 0, bottom: 0 }}
      style={{ x, y }}
      whileDrag={{ scale: 1.1, zIndex: 1000 }}
    >
      드래그 가능한 요소
    </motion.div>
  );
}
```

### 4. 모달 및 오버레이

**기능 설명:**
부드러운 전환 효과를 가진 모달과 오버레이를 구현합니다.

**구현 방법:**

```typescript
import { motion, AnimatePresence } from 'framer-motion';
import { useState } from 'react';

function ModalComponent() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <button onClick={() => setIsOpen(true)}>모달 열기</button>
      
      <AnimatePresence>
        {isOpen && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={() => setIsOpen(false)}
            style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundColor: 'rgba(0,0,0,0.5)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000,
            }}
          >
            <motion.div
              initial={{ scale: 0.8, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              exit={{ scale: 0.8, opacity: 0 }}
              onClick={(e) => e.stopPropagation()}
              style={{
                backgroundColor: 'white',
                padding: '2rem',
                borderRadius: '8px',
                maxWidth: '500px',
              }}
            >
              모달 콘텐츠
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </>
  );
}
```

### 5. 페이지 전환 애니메이션

**기능 설명:**
페이지 간 전환 시 부드러운 애니메이션 효과를 적용합니다.

**구현 방법:**

```typescript
import { motion, AnimatePresence } from 'framer-motion';
import { useRouter } from 'next/router';

function PageTransition({ children }: { children: React.ReactNode }) {
  const router = useRouter();

  return (
    <AnimatePresence mode="wait">
      <motion.div
        key={router.asPath}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: -20 }}
        transition={{ duration: 0.3 }}
      >
        {children}
      </motion.div>
    </AnimatePresence>
  );
}
```

---

## 구현 방법 상세 가이드

### 1. Framer Motion 설치 및 설정

```bash
# npm
npm install framer-motion

# pnpm
pnpm add framer-motion

# yarn
yarn add framer-motion
```

### 2. 기본 설정

```typescript
// app/layout.tsx 또는 _app.tsx
import { MotionConfig } from 'framer-motion';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <MotionConfig
      reducedMotion="user"
      transition={{
        type: "spring",
        stiffness: 300,
        damping: 30,
      }}
    >
      {children}
    </MotionConfig>
  );
}
```

### 3. 성능 최적화를 위한 설정

```typescript
import { motion, LazyMotion, domAnimation } from 'framer-motion';

// 코드 스플리팅을 통한 성능 최적화
function OptimizedMotionComponent() {
  return (
    <LazyMotion features={domAnimation}>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
      >
        최적화된 애니메이션
      </motion.div>
    </LazyMotion>
  );
}
```

### 4. 커스텀 훅 생성

```typescript
// hooks/use-scroll-animation.ts
import { useScroll, useTransform, MotionValue } from 'framer-motion';

export function useScrollAnimation(
  inputRange: [number, number],
  outputRange: [number, number]
) {
  const { scrollYProgress } = useScroll();
  return useTransform(scrollYProgress, inputRange, outputRange);
}

// 사용 예시
function Component() {
  const opacity = useScrollAnimation([0, 0.5], [1, 0]);
  const y = useScrollAnimation([0, 1], [0, -100]);
  
  return (
    <motion.div style={{ opacity, y }}>
      콘텐츠
    </motion.div>
  );
}
```

### 5. 애니메이션 프리셋 생성

```typescript
// lib/animations.ts
export const fadeIn = {
  initial: { opacity: 0 },
  animate: { opacity: 1 },
  exit: { opacity: 0 },
};

export const slideUp = {
  initial: { opacity: 0, y: 50 },
  animate: { opacity: 1, y: 0 },
  exit: { opacity: 0, y: -50 },
};

export const scaleIn = {
  initial: { opacity: 0, scale: 0.8 },
  animate: { opacity: 1, scale: 1 },
  exit: { opacity: 0, scale: 0.8 },
};

export const springTransition = {
  type: "spring",
  stiffness: 300,
  damping: 30,
};

// 사용 예시
<motion.div
  variants={fadeIn}
  initial="initial"
  animate="animate"
  exit="exit"
  transition={springTransition}
>
  콘텐츠
</motion.div>
```

---

## 코드 예제

### 완전한 예제: 인터랙티브 히어로 섹션

```typescript
'use client';

import { motion, useScroll, useTransform } from 'framer-motion';
import { useRef } from 'react';

export function HeroSection() {
  const ref = useRef<HTMLDivElement>(null);
  const { scrollYProgress } = useScroll({
    target: ref,
    offset: ["start start", "end start"]
  });

  const opacity = useTransform(scrollYProgress, [0, 0.5], [1, 0]);
  const scale = useTransform(scrollYProgress, [0, 0.5], [1, 0.8]);
  const y = useTransform(scrollYProgress, [0, 0.5], [0, -50]);

  return (
    <motion.section
      ref={ref}
      style={{ opacity, scale, y }}
      className="min-h-screen flex items-center justify-center"
    >
      <motion.div
        initial={{ opacity: 0, y: 50 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8, delay: 0.2 }}
        className="text-center"
      >
        <motion.h1
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.6, delay: 0.4 }}
          className="text-6xl font-bold mb-4"
        >
          환영합니다
        </motion.h1>
        <motion.p
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.6, delay: 0.6 }}
          className="text-xl text-gray-600"
        >
          스크롤하여 더 알아보세요
        </motion.p>
      </motion.div>
    </motion.section>
  );
}
```

### 완전한 예제: 카드 그리드 컴포넌트

```typescript
'use client';

import { motion } from 'framer-motion';
import { useState } from 'react';

interface Card {
  id: number;
  title: string;
  description: string;
  image: string;
}

export function CardGrid({ cards }: { cards: Card[] }) {
  const [selectedId, setSelectedId] = useState<number | null>(null);

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {cards.map((card, index) => (
        <motion.div
          key={card.id}
          layout
          initial={{ opacity: 0, y: 50 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: index * 0.1 }}
          whileHover={{ scale: 1.05, y: -5 }}
          onClick={() => setSelectedId(card.id)}
          className="bg-white rounded-lg shadow-lg overflow-hidden cursor-pointer"
        >
          <motion.img
            src={card.image}
            alt={card.title}
            layoutId={`image-${card.id}`}
            className="w-full h-48 object-cover"
          />
          <div className="p-6">
            <h3 className="text-xl font-bold mb-2">{card.title}</h3>
            <p className="text-gray-600">{card.description}</p>
          </div>
        </motion.div>
      ))}
    </div>
  );
}
```

### 완전한 예제: 스크롤 진행 표시기

```typescript
'use client';

import { motion, useScroll, useSpring } from 'framer-motion';

export function ScrollProgress() {
  const { scrollYProgress } = useScroll();
  const scaleX = useSpring(scrollYProgress, {
    stiffness: 100,
    damping: 30,
    restDelta: 0.001
  });

  return (
    <motion.div
      style={{ scaleX }}
      className="fixed top-0 left-0 right-0 h-1 bg-blue-500 origin-left z-50"
    />
  );
}
```

---

## 최적화 및 성능

### 1. 하드웨어 가속 활용

```typescript
// GPU 가속을 위한 transform 속성 사용
<motion.div
  style={{
    x: 0, // translateX는 GPU 가속
    y: 0, // translateY는 GPU 가속
    scale: 1, // scale은 GPU 가속
    // left, top 등은 GPU 가속 안 됨 - 피하세요
  }}
/>
```

### 2. will-change 속성 활용

```typescript
<motion.div
  style={{
    willChange: 'transform',
  }}
  animate={{ x: 100 }}
/>
```

### 3. 애니메이션 최적화

```typescript
// 불필요한 리렌더링 방지
const MotionComponent = memo(({ children }: { children: React.ReactNode }) => {
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
    >
      {children}
    </motion.div>
  );
});
```

### 4. 코드 스플리팅

```typescript
// 동적 임포트로 번들 크기 최적화
const LazyMotionComponent = dynamic(
  () => import('./MotionComponent'),
  { ssr: false }
);
```

### 5. 애니메이션 비활성화 옵션

```typescript
// 사용자 설정에 따른 애니메이션 감소
<motion.div
  initial={prefersReducedMotion ? false : { opacity: 0 }}
  animate={prefersReducedMotion ? false : { opacity: 1 }}
/>
```

---

## 추가 리소스

### 공식 문서
- [Framer Motion 공식 문서](https://www.framer.com/motion/)
- [React 공식 문서](https://react.dev/)

### 학습 자료
- Framer Motion 튜토리얼
- React 애니메이션 베스트 프랙티스
- 웹 성능 최적화 가이드

### 유용한 라이브러리
- `react-spring`: 대안 애니메이션 라이브러리
- `react-transition-group`: 전환 효과
- `gsap`: 고급 애니메이션 라이브러리

---

## 결론

Framer의 디자인 기능과 구현 방법을 이해하면, 현대적이고 인터랙티브한 웹사이트를 구축할 수 있습니다. 핵심은 Framer Motion을 활용한 부드러운 애니메이션과 사용자 경험을 최우선으로 고려하는 것입니다.

이 문서를 참고하여 프로젝트에 필요한 기능을 단계적으로 구현하시기 바랍니다.
