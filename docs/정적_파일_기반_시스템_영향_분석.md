# 정적 파일 기반 식약처 레시피 시스템 영향 분석

## 1. 영향받는 파일 목록

### 1.1 API 라우트 (5개)
- `app/api/mfds-recipes/route.ts` - 레시피 목록 조회
- `app/api/mfds-recipes/search/route.ts` - 레시피 검색
- `app/api/diet/meal/breakfast/[date]/route.ts` - 아침 식단 (백그라운드 식약처 API 호출)
- `app/api/diet/meal/lunch/[date]/route.ts` - 점심 식단 (백그라운드 식약처 API 호출)
- `app/api/diet/meal/dinner/[date]/route.ts` - 저녁 식단 (백그라운드 식약처 API 호출)

### 1.2 컴포넌트 (2개)
- `components/home/mfds-recipe-section.tsx` - 홈페이지 레시피 섹션
- `components/diet/mfds-recipe-search.tsx` - 레시피 검색 컴포넌트

### 1.3 라이브러리 (3개)
- `lib/services/mfds-recipe-api.ts` - 레시피 API 서비스
- `lib/recipes/foodsafety-api.ts` - 식약처 API 통합 서비스
- `lib/diet/mfds-recipe-fetcher.ts` - 레시피 대량 조회

### 1.4 식단 생성 로직 (2개)
- `lib/diet/personal-diet-generator.ts` - 개인 맞춤 식단 생성
- `lib/diet/queries.ts` - 식단 쿼리 (getRecipesWithNutrition, getMfdsRecipesOnly)

## 2. 데이터베이스 스키마 분석

### 2.1 recipes 테이블
현재 `recipes` 테이블에는 이미 식약처 관련 컬럼들이 존재:
- `foodsafety_rcp_seq` (TEXT, NULL 가능)
- `foodsafety_rcp_way2` (TEXT, NULL 가능)
- `foodsafety_rcp_pat2` (TEXT, NULL 가능)
- `foodsafety_info_eng` (NUMERIC, NULL 가능) - 칼로리
- `foodsafety_info_car` (NUMERIC, NULL 가능) - 탄수화물
- `foodsafety_info_pro` (NUMERIC, NULL 가능) - 단백질
- `foodsafety_info_fat` (NUMERIC, NULL 가능) - 지방
- `foodsafety_info_na` (NUMERIC, NULL 가능) - 나트륨
- `foodsafety_info_fiber` (NUMERIC, NULL 가능) - 식이섬유
- `foodsafety_rcp_parts_dtls` (TEXT, NULL 가능) - 재료 정보
- `foodsafety_att_file_no_main` (TEXT, NULL 가능) - 대표 이미지
- `foodsafety_att_file_no_mk` (TEXT, NULL 가능) - 만드는 법 이미지

**결론**: 기존 컬럼 구조는 유지하되, 정적 파일 경로를 저장할 컬럼 추가 고려

### 2.2 foodsafety_recipes_cache 테이블
- `rcp_seq` (TEXT, UNIQUE) - 레시피 순번
- `rcp_nm` (TEXT) - 레시피명
- `rcp_pat2`, `rcp_way2` (TEXT) - 요리종류, 조리방법
- `info_*` (NUMERIC) - 영양 정보
- `manual_data` (JSONB) - 조리법 데이터
- `cached_at` (TIMESTAMPTZ) - 캐시 시간

**결론**: 이 테이블은 정적 파일 시스템으로 대체 가능하지만, 기존 데이터 마이그레이션 고려

### 2.3 diet_plans 테이블
- `recipe_id` (UUID) - recipes 테이블 외래키
- `recipe_title` (TEXT) - 레시피 제목
- 기타 영양 정보 컬럼들

**결론**: `recipe_id`는 유지하되, 정적 파일 기반 레시피의 경우 `recipe_id`가 NULL일 수 있음

## 3. 마이그레이션 전략

### 3.1 데이터베이스 마이그레이션 필요사항

#### 옵션 1: 정적 파일 경로 저장 (권장)
- `recipes` 테이블에 `static_file_path` 컬럼 추가 (TEXT, NULL 가능)
- 정적 파일 기반 레시피는 `static_file_path`에 마크다운 파일 경로 저장
- 기존 API 기반 레시피는 `static_file_path`가 NULL

#### 옵션 2: 완전 파일 시스템 기반
- 데이터베이스에 저장하지 않고 파일 시스템만 사용
- `recipe_id`는 UUID 대신 `foodsafety-{RCP_SEQ}` 형식 사용
- `diet_plans.recipe_id`는 TEXT로 변경 필요 (기존 관계 깨짐)

**권장**: 옵션 1 (하이브리드 방식)
- 기존 데이터베이스 구조 유지
- 정적 파일 경로만 추가
- 점진적 마이그레이션 가능

### 3.2 마이그레이션 파일 계획

1. **recipes 테이블 확장**
   - `static_file_path` 컬럼 추가
   - `static_file_updated_at` 컬럼 추가 (선택)

2. **인덱스 추가**
   - `foodsafety_rcp_seq`에 인덱스 추가 (이미 있을 수 있음)
   - `static_file_path`에 인덱스 추가

3. **기존 데이터 마이그레이션**
   - `foodsafety_recipes_cache` 테이블 데이터를 정적 파일로 변환
   - 변환된 파일 경로를 `recipes.static_file_path`에 저장

## 4. 구현 단계별 영향도

### Phase 1: 정적 파일 로더 구현
**영향**: 없음 (새 파일 생성)

### Phase 2: API 라우트 수정
**영향**: 
- API 응답 형식 유지 (하위 호환성)
- 내부 로직만 정적 파일 로더로 변경

### Phase 3: 컴포넌트 수정
**영향**: 
- UI 변경 없음
- 데이터 소스만 변경

### Phase 4: 식단 생성 로직 수정
**영향**: 
- 식단 생성 알고리즘 유지
- 레시피 조회 로직만 변경

## 5. 하위 호환성 고려사항

1. **기존 API 응답 형식 유지**
   - 클라이언트 코드 변경 최소화
   - 정적 파일 데이터를 기존 인터페이스로 변환

2. **데이터베이스 관계 유지**
   - `diet_plans.recipe_id` → `recipes.id` 관계 유지
   - 정적 파일 기반 레시피도 `recipes` 테이블에 레코드 생성

3. **점진적 마이그레이션**
   - API 호출과 정적 파일 로더 병행 사용 가능
   - 우선순위: 정적 파일 > API 호출

## 6. 성능 개선 예상

### 현재 (API 호출)
- 레시피 조회: 1-10초
- 식단 생성: 5-30초
- 네트워크 의존: 필수

### 개선 후 (정적 파일)
- 레시피 조회: < 10ms
- 식단 생성: < 100ms
- 네트워크 의존: 없음

**성능 향상: 50-300배**

